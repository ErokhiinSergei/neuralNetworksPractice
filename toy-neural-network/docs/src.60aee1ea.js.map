{"version":3,"sources":["utils/random.ts","perceptronStuff/Perceptron.ts","utils/Canvas.ts","utils/loop.ts","utils/map.ts","perceptronStuff/Point.ts","perceptronStuff/perceptronModule.ts","neuralNetworkStuff/Matrix.ts","neuralNetworkStuff/NeuralNetwork.ts","neuralNetworkStuff/neuralNetworkModule.ts","index.ts"],"names":[],"mappings":"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","file":"src.60aee1ea.js","sourceRoot":"../src","sourcesContent":["export const random = (min: number, max: number) =>\n  // получить случайное число от (min-0.5) до (max+0.5)\n  min - 0.5 + Math.random() * (max - min + 1);\n\nexport const getRandomInt = (min: number, max: number) => {\n  return Math.round(random(min, max));\n};\n","import { random } from \"../utils/random\";\n\nexport class Perceptron {\n  private weights: number[];\n  private learningRate: number;\n  constructor(n: number, lerningRate: number) {\n    this.learningRate = lerningRate;\n    this.weights = new Array(n);\n    for (let i = 0; i < this.weights.length; i++) {\n      this.weights[i] = random(-1, 1);\n    }\n  }\n  private sign(n: number) {\n    if (n < 0) return -1;\n    return 1;\n  }\n  guess(inputs: number[]) {\n    let sum = 0;\n    for (let i = 0; i < this.weights.length; i++) {\n      sum += inputs[i] * this.weights[i];\n    }\n    let output = this.sign(sum);\n    return output;\n  }\n  guessY(x: number) {\n    const w = this.weights;\n    return -(w[2] / w[1]) - (w[0] / w[1]) * x;\n  }\n  train(inputs: number[], target: number) {\n    const guess = this.guess(inputs);\n    const error = target - guess;\n    for (let i = 0; i < this.weights.length; i++) {\n      this.weights[i] += error * inputs[i] * this.learningRate;\n    }\n  }\n}\n","type Point = {\n  x: number;\n  y: number;\n};\nexport class Canvas {\n  ctx: CanvasRenderingContext2D;\n  canvas: HTMLCanvasElement;\n  width: number;\n  height: number;\n\n  constructor(canvas: HTMLCanvasElement ,width: number, height: number) {\n    this.width = width;\n    this.height = height;\n    this.canvas = canvas;\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.ctx = this.canvas.getContext(\"2d\");\n  }\n\n  drawPoint(p: Point, color: string, size: number = 6, stroke?: boolean) {\n    this.ctx.fillStyle = color;\n    this.ctx.beginPath();\n    this.ctx.arc(p.x, p.y, size, 0, 2 * Math.PI, true);\n    this.ctx.fill();\n    if (stroke) this.ctx.stroke();\n  }\n  drawLine(start: Point, end: Point) {\n    this.ctx.beginPath();\n    this.ctx.moveTo(start.x, start.y);\n    this.ctx.lineTo(end.x, end.y);\n    this.ctx.stroke();\n  }\n  clear() {\n    this.ctx.clearRect(0, 0, this.width, this.height);\n  }\n}\n","export const loop = (fn: () => void) => {\n  window.requestAnimationFrame(() => loop(fn));\n  fn();\n};\n","export const constrain: (n: number, low: number, high: number) => number = (\n  n,\n  low,\n  high\n) => Math.max(Math.min(n, high), low);\n\nexport const map: (\n  n: number,\n  start1: number,\n  stop1: number,\n  start2: number,\n  stop2: number,\n  withinBounds?: boolean\n) => number = (n, start1, stop1, start2, stop2, withinBounds) => {\n  const newval = ((n - start1) / (stop1 - start1)) * (stop2 - start2) + start2;\n  if (!withinBounds) {\n    return newval;\n  }\n  if (start2 < stop2) {\n    return constrain(newval, start2, stop2);\n  } else {\n    return constrain(newval, stop2, start2);\n  }\n};\n\nexport function flatMap<T, U>(array: T[], callbackfn: (value: T, index: number, array: T[]) => U[]): U[] {\n  return Array.prototype.concat(...array.map(callbackfn));\n}","import { random } from \"../utils/random\";\nimport { Canvas } from \"../utils/Canvas\";\nimport { f, canvas } from \"./perceptronModule\";\nimport { map } from \"../utils/map\";\n\nconst COLOR_A = \"white\";\nconst COLOR_B = \"black\";\nexport class Point {\n  label: number;\n  canvas: Canvas;\n  x: number;\n  y: number;\n\n  constructor(x = random(-1, 1), y = random(-1, 1)) {\n    this.x = x;\n    this.y = y;\n    if (this.y < f(this.x)) this.label = -1;\n    else this.label = 1;\n  }\n  pixelX() {\n    return map(this.x, -1, 1, 0, canvas.width);\n  }\n  pixelY() {\n    return map(this.y, -1, 1, canvas.height, 0);\n  }\n  show() {\n    let color: string;\n    if (this.label === 1) color = COLOR_A;\n    else color = COLOR_B;\n    canvas.drawPoint({ x: this.pixelX(), y: this.pixelY() }, color, 6, true);\n  }\n}\n","import { Perceptron } from \"./Perceptron\";\nimport { Canvas } from \"../utils/Canvas\";\nimport { loop } from \"../utils/loop\";\nimport { Point } from \"./Point\";\n\nconst WIDTH = 500;\nconst HEIGTH = 500;\nconst BIAS = 1;\n\nconst COLOR_ERROR = \"#cf3030\";\nconst COLOR_SUCCESS = \"#2ad55a\";\n\nexport const canvas = new Canvas(\n  document.querySelector(\"#perceptron\"),\n  WIDTH,\n  HEIGTH\n);\n// Line function\nexport const f: (x: number) => number = (x) => 0.89 * x + 0.2;\nconst points: Point[] = new Array(200);\nfor (let i = 0; i < points.length; i++) {\n  points[i] = new Point();\n}\nconst brain = new Perceptron(3, 0.005);\nconst p1 = new Point(-1, f(-1));\nconst p2 = new Point(1, f(1));\nlet count = 0;\nexport const perceptronModule = () => {\n  loop(() => {\n    canvas.clear();\n\n    canvas.drawLine(\n      { x: p1.pixelX(), y: p1.pixelY() },\n      { x: p2.pixelX(), y: p2.pixelY() }\n    );\n    for (let point of points) {\n      point.show();\n    }\n    for (let point of points) {\n      const inputs = [point.x, point.y, BIAS];\n      const target = point.label;\n      const guess = brain.guess(inputs);\n      let color: string;\n      if (guess === target) color = COLOR_SUCCESS;\n      else color = COLOR_ERROR;\n      canvas.drawPoint({ x: point.pixelX(), y: point.pixelY() }, color, 3);\n    }\n\n    const training = points[count];\n    const inputs = [training.x, training.y, BIAS];\n    const target = training.label;\n    brain.train(inputs, target);\n    const p3 = new Point(-1, brain.guessY(-1));\n    const p4 = new Point(1, brain.guessY(1));\n    canvas.drawLine(\n      { x: p3.pixelX(), y: p3.pixelY() },\n      { x: p4.pixelX(), y: p4.pixelY() }\n    );\n    count++;\n    if (count === points.length) count = 0;\n  });\n};\n","import { random } from \"../utils/random\";\nimport { flatMap } from \"../utils/map\";\n\nexport class Matrix {\n  rows: number;\n  columns: number;\n  data: number[][];\n\n  constructor(rows: number, columns: number) {\n    this.rows = rows;\n    this.columns = columns;\n    this.data = Array(rows).fill(Array(columns).fill(0));\n  }\n\n  copy() {\n    return Matrix.add(new Matrix(this.rows, this.columns), this);\n  }\n\n  static map(\n    matrix: Matrix,\n    callback: (e: number, i: number, j: number) => number\n  ) {\n    return matrix.copy().forEach(callback);\n  }\n  map(callback: (e: number, i: number, j: number) => number) {\n    return this.data.map((row, i) => row.map((e, j) => callback(e, i, j)));\n  }\n  forEach(callback: (e: number, i: number, j: number) => number) {\n    this.data = this.map(callback);\n    return this;\n  }\n\n  static add(a: Matrix, b: Matrix) {\n    return new Matrix(a.rows, a.columns).forEach(\n      (element, i, j) => element + b.data[i][j]\n    );\n  }\n  add(a: number | Matrix) {\n    if (a instanceof Matrix) {\n      this.data = this.map((element, i, j) => element + a.data[i][j]);\n    } else {\n      this.data = this.map((element) => element + a);\n    }\n    return this;\n  }\n\n  static subtract(a: Matrix, b: Matrix) {\n    return new Matrix(a.rows, a.columns).forEach(\n      (_, i, j) => a.data[i][j] - b.data[i][j]\n    );\n  }\n  subtract(n: number) {\n    this.add(n * -1);\n    return this;\n  }\n\n  static multiply(a: Matrix, b: Matrix) {\n    return new Matrix(a.rows, b.columns).forEach((_, i, j) =>\n      a.data[i].reduce((acc, e, index) => e * b.data[index][j] + acc, 0)\n    );\n  }\n  multiply(n: number | Matrix) {\n    if (n instanceof Matrix) {\n      if (this.rows !== n.rows || this.columns !== n.columns) {\n        console.log(\"Columns and Rows of A must match Columns and Rows of B.\");\n        return;\n      }\n      // hadamard product\n      return this.forEach((e, i, j) => e * n.data[i][j]);\n    }\n    this.data = this.map((element) => element * n);\n    return this;\n  }\n\n  static transpose(matrix: Matrix) {\n    return new Matrix(matrix.columns, matrix.rows).forEach(\n      (_, i, j) => matrix.data[j][i]\n    );\n  }\n\n  randomize() {\n    this.data = this.map(() => random(-1, 1));\n    return this;\n  }\n\n  print() {\n    console.table(this.data);\n    return this;\n  }\n\n  static fromRaw(data: number[][]) {\n    let m = new Matrix(data.length, data[0].length);\n    m.data = m.map((_, i, j) => data[i][j]);\n    return m;\n  }\n  toArray() {\n    return flatMap(this.data, (e) => e);\n  }\n}\n","import { Matrix } from \"./Matrix\";\nconst sigmoid = (x: number) => 1 / (1 + Math.exp(-x));\nconst dSigmoid = (y: number): number => y * (1 - y);\nexport class NeuralNetwork {\n  inputNodes: number;\n  hiddenNodes: number;\n  outputNodes: number;\n  hiddenWeights: Matrix;\n  outputWeights: Matrix;\n  hiddenBias: Matrix;\n  outputBias: Matrix;\n  learningRate: number;\n\n  constructor(inputNodes: number, hiddenNodes: number, outputNodes: number) {\n    this.inputNodes = inputNodes;\n    this.hiddenNodes = hiddenNodes;\n    this.outputNodes = outputNodes;\n    this.learningRate = 0.1;\n\n    this.hiddenWeights = new Matrix(\n      this.hiddenNodes,\n      this.inputNodes\n    ).randomize();\n    this.outputWeights = new Matrix(\n      this.outputNodes,\n      this.hiddenNodes\n    ).randomize();\n\n    this.hiddenBias = new Matrix(this.hiddenNodes, 1).randomize();\n    this.outputBias = new Matrix(this.outputNodes, 1).randomize();\n  }\n\n  feedforward(inputs: Matrix) {\n    let hiddenLayer = Matrix.multiply(this.hiddenWeights, inputs)\n      .add(this.hiddenBias)\n      .forEach(sigmoid);\n\n    let outputLayer = Matrix.multiply(this.outputWeights, hiddenLayer)\n      .add(this.outputBias)\n      .forEach(sigmoid);\n\n    return outputLayer;\n  }\n\n  train(inputs: Matrix, targets: Matrix) {\n    let hiddenLayer = Matrix.multiply(this.hiddenWeights, inputs)\n      .add(this.hiddenBias)\n      .forEach(sigmoid);\n\n    let outputLayer = Matrix.multiply(this.outputWeights, hiddenLayer)\n      .add(this.outputBias)\n      .forEach(sigmoid);\n\n    //\n    //\n    // OUTPUT\n\n    let outputErrors = Matrix.subtract(targets, outputLayer);\n\n    // Calculate gradient\n    let outputGradients = Matrix.map(outputLayer, dSigmoid);\n    outputGradients.multiply(outputErrors);\n    outputGradients.multiply(this.learningRate);\n\n    // Calculate delta\n    let weightOutputDeltas = Matrix.multiply(\n      outputGradients,\n      Matrix.transpose(hiddenLayer)\n    );\n\n    this.outputWeights.add(weightOutputDeltas);\n    this.outputBias.add(outputGradients);\n\n    //\n    //\n    // HIDDEN\n\n    let hiddenErrors = Matrix.multiply(\n      Matrix.transpose(this.outputWeights),\n      outputErrors\n    );\n\n    // Calculate gradient\n    let hiddenGradients = Matrix.map(hiddenLayer, dSigmoid);\n    hiddenGradients.multiply(hiddenErrors);\n    hiddenGradients.multiply(this.learningRate);\n\n    // Calculate delta\n    let weightHiddenDeltas = Matrix.multiply(\n      hiddenGradients,\n      Matrix.transpose(inputs)\n    );\n\n    this.hiddenWeights.add(weightHiddenDeltas);\n    this.hiddenBias.add(hiddenGradients);\n  }\n}\n","import { NeuralNetwork } from \"./NeuralNetwork\";\nimport { Matrix } from \"./Matrix\";\nimport { getRandomInt } from \"../utils/random\";\nimport { loop } from \"../utils/loop\";\nimport { canvas } from \"../perceptronStuff/perceptronModule\";\n\nexport const neuralNetworkModule = () => {\n  const nn = new NeuralNetwork(2, 2, 1);\n  window.nn = nn\n  window.Matrix = Matrix\n\n  let trainingData = [\n    { inputs: Matrix.fromRaw([[0], [0]]), targets: Matrix.fromRaw([[0]]) },\n    { inputs: Matrix.fromRaw([[0], [1]]), targets: Matrix.fromRaw([[1]]) },\n    { inputs: Matrix.fromRaw([[1], [0]]), targets: Matrix.fromRaw([[1]]) },\n    { inputs: Matrix.fromRaw([[1], [1]]), targets: Matrix.fromRaw([[0]]) },\n  ];\n\n  loop(() => {\n    canvas.clear();\n\n    const data = trainingData[getRandomInt(0, 3)];\n    nn.train(data.inputs, data.targets);\n  });\n};\n","import { perceptronModule } from \"./perceptronStuff/perceptronModule\";\nimport { neuralNetworkModule } from \"./neuralNetworkStuff/neuralNetworkModule\";\n\nperceptronModule();\nneuralNetworkModule();\n"]}