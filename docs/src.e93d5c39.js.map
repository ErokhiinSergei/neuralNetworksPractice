{"version":3,"sources":["utils/random.ts","Perceptron.ts","Canvas.ts","utils/loop.ts","utils/map.ts","Point.ts","index.ts"],"names":[],"mappings":"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","file":"src.e93d5c39.js","sourceRoot":"../src","sourcesContent":["export const random = (min: number, max: number) => \n   Math.random() * (max - min) + min;\n\n","import { random } from \"./utils/random\";\n\nexport class Perceptron {\n  private weights: number[];\n  private learningRate: number;\n  constructor(n: number, lerningRate: number) {\n    this.learningRate = lerningRate;\n    this.weights = new Array(n);\n    for (let i = 0; i < this.weights.length; i++) {\n      this.weights[i] = random(-1, 1);\n    }\n  }\n  private sign(n: number) {\n    if (n < 0) return -1;\n    return 1;\n  }\n  guess(inputs: number[]) {\n    let sum = 0;\n    for (let i = 0; i < this.weights.length; i++) {\n      sum += inputs[i] * this.weights[i];\n    }\n    let output = this.sign(sum);\n    return output;\n  }\n  guessY(x: number) {\n    const w = this.weights;\n    return -(w[2] / w[1]) - (w[0] / w[1]) * x;\n  }\n  train(inputs: number[], target: number) {\n    const guess = this.guess(inputs);\n    const error = target - guess;\n    for (let i = 0; i < this.weights.length; i++) {\n      this.weights[i] += error * inputs[i] * this.learningRate;\n    }\n  }\n}\n","type Point = {\n  x: number;\n  y: number;\n};\nexport class Canvas {\n  ctx: CanvasRenderingContext2D;\n  canvas: HTMLCanvasElement;\n  width: number;\n  height: number;\n\n  constructor(width: number, height: number) {\n    this.width = width;\n    this.height = height;\n    this.canvas = document.querySelector(\"canvas\");\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.ctx = this.canvas.getContext(\"2d\");\n  }\n\n  drawPoint(p: Point, color: string, size: number = 6, stroke?: boolean) {\n    this.ctx.fillStyle = color;\n    this.ctx.beginPath();\n    this.ctx.arc(p.x, p.y, size, 0, 2 * Math.PI, true);\n    this.ctx.fill();\n    if (stroke) this.ctx.stroke();\n  }\n  drawLine(start: Point, end: Point) {\n    this.ctx.beginPath();\n    this.ctx.moveTo(start.x, start.y);\n    this.ctx.lineTo(end.x, end.y);\n    this.ctx.stroke();\n  }\n  clear() {\n    this.ctx.clearRect(0, 0, this.width, this.height);\n  }\n}\n","export const loop = (fn: () => void) => {\n  window.requestAnimationFrame(() => loop(fn));\n  fn();\n};\n","export const constrain: (n: number, low: number, high: number) => number = (\n  n,\n  low,\n  high\n) => Math.max(Math.min(n, high), low);\n\nexport const map: (\n  n: number,\n  start1: number,\n  stop1: number,\n  start2: number,\n  stop2: number,\n  withinBounds?: boolean\n) => number = (n, start1, stop1, start2, stop2, withinBounds) => {\n  const newval = ((n - start1) / (stop1 - start1)) * (stop2 - start2) + start2;\n  if (!withinBounds) {\n    return newval;\n  }\n  if (start2 < stop2) {\n    return constrain(newval, start2, stop2);\n  } else {\n    return constrain(newval, stop2, start2);\n  }\n};\n","import { random } from \"./utils/random\";\nimport { Canvas } from \"./Canvas\";\nimport { f, canvas } from \".\";\nimport { map } from \"./utils/map\";\n\nconst COLOR_A = \"white\";\nconst COLOR_B = \"black\";\nexport class Point {\n  label: number;\n  canvas: Canvas;\n  x: number;\n  y: number;\n\n  constructor(x = random(-1, 1), y = random(-1, 1)) {\n    this.x = x;\n    this.y = y;\n    if (this.y < f(this.x)) this.label = -1;\n    else this.label = 1;\n  }\n  pixelX() {\n    return map(this.x, -1, 1, 0, canvas.width);\n  }\n  pixelY() {\n    return map(this.y, -1, 1, canvas.height, 0);\n  }\n  show() {\n    let color: string;\n    if (this.label === 1) color = COLOR_A;\n    else color = COLOR_B;\n    canvas.drawPoint({ x: this.pixelX(), y: this.pixelY() }, color, 6, true);\n  }\n}\n","import { Perceptron } from \"./Perceptron\";\nimport { Canvas } from \"./Canvas\";\nimport { loop } from \"./utils/loop\";\nimport { Point } from \"./Point\";\n\nconst WIDTH = 500;\nconst HEIGTH = 500;\n\nconst COLOR_ERROR = \"#cf3030\";\nconst COLOR_SUCCESS = \"#2ad55a\";\n\n// Line function\nexport const f: (x: number) => number = (x) => 0.89 * x + 0.2;\nconst BIAS = 1;\nexport const canvas = new Canvas(WIDTH, HEIGTH);\nconst points: Point[] = new Array(200);\nconst brain = new Perceptron(3, 0.005);\nlet count = 0;\n\nconst p1 = new Point(-1, f(-1));\nconst p2 = new Point(1, f(1));\n\nfor (let i = 0; i < points.length; i++) {\n  points[i] = new Point();\n}\n\nloop(() => {\n  canvas.clear();\n\n  canvas.drawLine(\n    { x: p1.pixelX(), y: p1.pixelY() },\n    { x: p2.pixelX(), y: p2.pixelY() }\n  );\n  for (let point of points) {\n    point.show();\n  }\n  for (let point of points) {\n    const inputs = [point.x, point.y, BIAS];\n    const target = point.label;\n    const guess = brain.guess(inputs);\n    let color: string;\n    if (guess === target) color = COLOR_SUCCESS;\n    else color = COLOR_ERROR;\n    canvas.drawPoint({ x: point.pixelX(), y: point.pixelY() }, color, 3);\n  }\n\n  const training = points[count];\n  const inputs = [training.x, training.y, BIAS];\n  const target = training.label;\n  brain.train(inputs, target);\n  const p3 = new Point(-1, brain.guessY(-1));\n  const p4 = new Point(1, brain.guessY(1));\n  canvas.drawLine(\n    { x: p3.pixelX(), y: p3.pixelY() },\n    { x: p4.pixelX(), y: p4.pixelY() }\n  );\n  count++;\n  if (count === points.length) count = 0;\n});\n"]}